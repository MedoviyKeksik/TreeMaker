unit Database;

interface

uses
  Vcl.Graphics,
  Vcl.ExtCtrls,
  System.Types,
  SysUtils;

type
  TControlObjectResizeProc = procedure(Sender: TObject; const X, Y: Integer);

  TControlObject = class
  protected
    FId: Integer;
    FIsVisible, FIsSelected: Boolean;
    FCanvas: TCanvas;
    FLeft, FTop: Integer;
    FWidth, FHeigth: Integer;
    FOnResize, FOnMove: TControlObjectResizeProc;
    procedure SetCanvas(ACanvas: TCanvas);
  public
    constructor Create;
    destructor Destroy;
    procedure SetPosition(const X, Y: Integer);
    procedure SetSize(const AWidth, AHeigth: Integer);
    procedure DrawControls;
    property OnResize: TControlObjectResizeProc read FOnResize write FOnResize;
    property OnMove: TControlObjectResizeProc read FOnMove write FOnMove;
    property Canvas: TCanvas read FCanvas write SetCanvas;
    property Visible: Boolean read FIsVisible write FIsVisible;
    property Selected: Boolean read FIsSelected write FIsSelected;
    property Id: Integer read FId;
    function GetCenter: TPoint;
  end;

  TText = class(TControlObject)
  private
    FCaption: String;
    FBrush: TBrush;
    FFont: TFont;
    FTextFormat: TTextFormat;
  public
    constructor Create;
    destructor Destroy;
    procedure Draw;
    function IsInside(const X, Y: Integer): Boolean;
    property Brush: TBrush read FBrush write FBrush;
    property Caption: String read FCaption write FCaption;
    property Font: TFont read FFont write FFont;
    property TextFormat: TTextFormat read FTextFormat write FTextFormat;
  end;

  TElement = class(TControlObject)
  private
    FText: TText;
    FShape: TShapeType;
    FBrush: TBrush;
    FPen: TPen;
    procedure SetCanvas(Canvas: TCanvas);
  public
    constructor Create;
    destructor Destroy;

    procedure SetPosition(const X, Y: Integer);
    procedure SetSize(const AWidth, AHeigth: Integer);
    function IsInside(const X, Y: Integer): Boolean;
    procedure Draw;
    property Canvas: TCanvas read FCanvas write SetCanvas;
  end;

  TConnector = record
    case BindToElement: Boolean of
      True:
        (Element: TElement);
      False:
        (Pos: TPoint);
  end;

  TLine = class
  private
    FStart, FFinish: TConnector;
    FText: TText;
    FIsSelected: Boolean;
    Pen: TPen;
    Canvas: TCanvas;
  public
    constructor Create;
    destructor Destroy;

    procedure Move;
    procedure Draw;

    function IsInside(const X, Y: Integer): Boolean;
    procedure SetCanvas(const Canvas: TCanvas);
  end;

implementation

uses
  MainWindow;

const
  DefaultTextFormat: TTextFormat = [tfSingleLine, tfCenter, tfVerticalCenter];

  { TLine }

constructor TLine.Create;
begin
  FText := TText.Create;
  FText.FCaption := '';
  Pen := TPen.Create;
end;

destructor TLine.Destroy;
begin
  FText.Destroy;
  Pen.Destroy;
  Inherited;
end;

procedure TLine.Draw;
var
  StartPoint, FinishPoint: TPoint;
begin
  case FStart.BindToElement of
    True:
      StartPoint := FStart.Element.GetCenter;
    False:
      StartPoint := FStart.Pos;
  end;
  Canvas.MoveTo(StartPoint.X, StartPoint.Y);
  Canvas.Pen := Pen;
  case FFinish.BindToElement of
    True:
      FinishPoint := FFinish.Element.GetCenter;
    False:
      FinishPoint := FFinish.Pos;
  end;
  Canvas.LineTo(FinishPoint.X, FinishPoint.Y);
  FText.FLeft := StartPoint.X;
  FText.FTop := StartPoint.Y;
  FText.FWidth := FinishPoint.X - StartPoint.X;
  FText.FHeigth := FinishPoint.Y - StartPoint.Y;
  FText.Draw;
end;

function TLine.IsInside(const X, Y: Integer): Boolean;
begin
  Result := False;

end;

procedure TLine.Move;
begin

end;

procedure TLine.SetCanvas(const Canvas: TCanvas);
begin
  Self.Canvas := Canvas;
  FText.SetCanvas(Canvas);
end;

{ TText }

constructor TText.Create;
begin
  FBrush := TBrush.Create;
  FFont := TFont.Create;
  FTextFormat := DefaultTextFormat;
  FCaption := 'Some text';
end;

destructor TText.Destroy;
begin
  FFont.Destroy;
  Inherited;
end;

procedure TText.Draw;
var
  Rect: TRect;
begin
  Rect := TRect.Create(FLeft, FTop, FLeft + FWidth, FTop + FHeigth);
  FCanvas.Font := FFont;
  FCanvas.Brush := FBrush;
  FCanvas.TextRect(Rect, FCaption, FTextFormat);
end;

function TText.IsInside(const X, Y: Integer): Boolean;
begin
  Result := (X >= FLeft) and (Y >= FTop) and (X <= FLeft + FWidth) and
    (Y <= FTop + FHeigth);
end;

{ TElement }

constructor TElement.Create;
begin
  FText := TText.Create;
  FBrush := TBrush.Create;
  FPen := TPen.Create;
end;

destructor TElement.Destroy;
begin
  FText.Free;
  FBrush.Free;
  FPen.Free;
  Inherited;
end;

procedure TElement.Draw;
begin
  Canvas.Pen := FPen;
  Canvas.Brush := FBrush;
  case FShape of
    stRectangle, stSquare:
      Canvas.Rectangle(FLeft, FTop, FLeft + FWidth, FTop + FHeigth);
    stSquare:
      ;
    // stRoundRect: ;
    // stRoundSquare: ;
    stEllipse, stCircle:
      Canvas.Ellipse(FLeft, FTop, FLeft + FWidth, FTop + FHeigth);
  end;
  FText.Brush := FBrush;
  FText.Draw;
end;

function TElement.IsInside(const X, Y: Integer): Boolean;

  function IsInEllipse(const X, Y, a2, b2: Integer): Boolean;
  begin
    if (a2 = 0) or (b2 = 0) then
      Result := False
    else
      Result := (Sqr(X) / Sqr(a2) + Sqr(Y) / Sqr(b2)) <= 2.0;
  end;

begin
  case FShape of
    stRectangle, stSquare:
      Result := (X >= FLeft) and (Y >= FTop) and (X <= FLeft + FWidth) and
        (Y <= FTop + FHeigth);
    // stRoundRect: ;
    // stRoundSquare: ;
    stEllipse, stCircle:
      Result := IsInEllipse(X - FLeft, Y - FTop, FWidth, FHeigth);
  end;
end;

procedure TElement.SetCanvas(const Canvas: TCanvas);
begin
  Inherited;
  FText.SetCanvas(Canvas);
end;

procedure TElement.SetPosition(const X, Y: Integer);
begin
  Inherited;
  FText.FLeft := X;
  FText.FTop := Y;
end;

procedure TElement.SetSize(const AWidth, AHeigth: Integer);
begin
  Inherited;
  FText.FWidth := AWidth;
  FText.FHeigth := AHeigth;
end;

{ TControlObject }

constructor TControlObject.Create;
begin
  Inherited;
end;

destructor TControlObject.Destroy;
begin
  Inherited;
end;

procedure TControlObject.DrawControls;

const
  DotSize = 3;

  procedure DrawDot(const X, Y: Integer);
  begin
    FCanvas.Rectangle(X - DotSize, Y - DotSize, X + DotSize, Y + DotSize);
  end;

begin
  if FIsVisible then
  begin
    FCanvas.Brush.Style := bsClear;
    FCanvas.Pen.Style := psDash;
    FCanvas.Pen.Color := clBlue;
    FCanvas.Rectangle(FLeft, FTop, FLeft + FWidth, FTop + FHeigth);
    FCanvas.Brush.Style := bsSolid;
    FCanvas.Brush.Color := clGreen;
    FCanvas.Pen.Style := psSolid;
    FCanvas.Pen.Color := clBlack;
    DrawDot(FLeft, FTop); // 0
    DrawDot(FLeft + FWidth shr 1, FTop); // 1
    DrawDot(FLeft + FWidth, FTop); // 2
    DrawDot(FLeft + FWidth, FTop + FHeigth shr 1); // 3
    DrawDot(FLeft + FWidth, FTop + FHeigth); // 4
    DrawDot(FLeft + FWidth shr 1, FTop + FHeigth); // 5
    DrawDot(FLeft, FTop + FHeigth); // 6
    DrawDot(FLeft, FTop + FHeigth shr 1); // 7
  end;
end;

function TControlObject.GetCenter: TPoint;
begin
  Result.X := FLeft + FWidth shr 1;
  Result.Y := FTop + FHeigth shr 1;
end;

procedure TControlObject.SetCanvas(ACanvas: TCanvas);
begin
  Self.FCanvas := ACanvas;
end;

procedure TControlObject.SetPosition(const X, Y: Integer);
begin
  FLeft := X;
  FTop := Y;
end;

procedure TControlObject.SetSize(const AWidth, AHeigth: Integer);
begin
  FWidth := AWidth;
  FHeigth := AHeigth;
end;

initialization

end.
